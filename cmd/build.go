package cmd

import (
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"

	"github.com/appist/appy/pack"
	"github.com/appist/appy/support"
	"github.com/dustin/go-humanize"
	"github.com/otiai10/copy"
	"github.com/shurcooL/vfsgen"
)

var (
	assetTplPath = "pkg/app/asset.go"
)

func newBuildCommand(asset *support.Asset, logger *support.Logger, server *pack.Server) *Command {
	cmd := &Command{
		Use:   "build",
		Short: "Compile the static assets into go files and build the release build binary (only available in debug build)",
		Run: func(cmd *Command, args []string) {
			wd, err := os.Getwd()
			if err != nil {
				logger.Fatal(err)
			}

			binaryName := path.Base(wd)
			releasePath := "dist"
			os.RemoveAll(releasePath)

			if _, err := os.Stat(wd + "/package.json"); !os.IsNotExist(err) {
				ssrPaths := []string{}
				for _, route := range server.Routes() {
					if route.Method == "GET" {
						ssrPaths = append(ssrPaths, route.Path)
					}
				}

				logger.Info("Building the web app...")
				buildWebCmd := exec.Command("npm", "run", "build")
				buildWebCmd.Env = os.Environ()
				buildWebCmd.Env = append(buildWebCmd.Env, "APPY_SSR_ROUTES="+strings.Join(ssrPaths, ","))
				buildWebCmd.Dir = wd
				buildWebCmd.Stdout = os.Stdout
				buildWebCmd.Stderr = os.Stderr
				if err := buildWebCmd.Run(); err != nil {
					logger.Fatal(err)
				}
				logger.Info("Building the web app... DONE")
			}

			logger.Infof("Copying server-side assets into '%s' folder...", releasePath)

			err = copy.Copy(asset.Layout().Docker(), releasePath+"/"+asset.Layout().Docker())
			if err != nil {
				logger.Fatal(err)
			}

			err = copy.Copy(asset.Layout().View(), releasePath+"/"+asset.Layout().View())
			if err != nil {
				logger.Fatal(err)
			}

			err = copy.Copy(asset.Layout().Locale(), releasePath+"/"+asset.Layout().Locale())
			if err != nil {
				logger.Fatal(err)
			}

			err = copy.Copy(asset.Layout().Config(), releasePath+"/"+asset.Layout().Config())
			if err != nil {
				logger.Fatal(err)
			}

			keyFiles, _ := filepath.Glob(releasePath + "/" + asset.Layout().Config() + "/*.key")
			for _, keyFile := range keyFiles {
				os.Remove(keyFile)
			}

			gitIgnoreFiles, _ := filepath.Glob(releasePath + "/**/.gitkeep")
			for _, gitIgnoreFile := range gitIgnoreFiles {
				os.Remove(gitIgnoreFile)
			}

			logger.Infof("Copying server-side assets into '%s' folder... DONE", releasePath)
			oldStdout := os.Stdout
			os.Stdout = nil

			generateAssetTemplate(logger)
			logger.Infof("Compiling '%s' folder into '%s'...", releasePath, assetTplPath)
			err = vfsgen.Generate(http.Dir(releasePath), vfsgen.Options{PackageName: "app", Filename: assetTplPath, VariableName: "asset"})
			if err != nil {
				logger.Fatal(err)
			}
			logger.Infof("Compiling '%s' folder into '%s'... DONE", releasePath, assetTplPath)
			os.Stdout = oldStdout

			if _, err := os.Stat(wd + "/pkg/graphql/config.yml"); !os.IsNotExist(err) {
				logger.Info("Generating GraphQL boilerplate code...")
				err = generateGQL()
				if err != nil {
					logger.Fatal(err.Error())
				}

				logger.Info("Generating GraphQL boilerplate code... DONE")
			}

			logger.Info("Building the binary...")
			goPath, err := exec.LookPath("go")
			if err != nil {
				logger.Fatal(err)
			}

			buildBinaryCmd := exec.Command(goPath, "build", "-a", "-tags", "netgo jsoniter", "-ldflags", "-w -extldflags '-static' -X github.com/appist/support.Build=release", "-o", binaryName, ".")
			buildBinaryCmd.Env = os.Environ()
			buildBinaryCmd.Stderr = os.Stderr
			if err = buildBinaryCmd.Run(); err != nil {
				logger.Fatal(err)
			}
			fi, _ := os.Stat(binaryName)
			logger.Infof("Building the binary... DONE (size: %s)", humanize.Bytes(uint64(fi.Size())))

			_, err = exec.LookPath("upx")
			if err == nil {
				logger.Info("Compressing the binary with upx...")
				compressBinaryCmd := exec.Command("upx", binaryName)
				compressBinaryCmd.Stderr = os.Stderr
				if err = compressBinaryCmd.Run(); err != nil {
					logger.Fatal(err)
				}
				fi, _ := os.Stat(binaryName)
				logger.Infof("Compressing the binary with upx... DONE (size: %s)", humanize.Bytes(uint64(fi.Size())))
			}
		},
	}

	return cmd
}

func generateAssetTemplate(logger *support.Logger) {
	os.Remove(assetTplPath)

	template := []byte(`
// Generated by appy. DO NOT EDIT.
package app
import "net/http"
var assets http.FileSystem
`)
	err := ioutil.WriteFile(assetTplPath, template, 0644)
	if err != nil {
		logger.Fatal(err)
	}
}
